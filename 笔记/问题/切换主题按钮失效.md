## 问题根源

主要问题是 **ConfigManager 实例冲突**：
- 在 <mcfile name="main.cpp" path="d:/QT_Learn/Projects/QKChatApp/client/src/main.cpp"></mcfile> 中创建了全局 ConfigManager 实例并暴露给 QML
- 但在 <mcfile name="main.qml" path="d:/QT_Learn/Projects/QKChatApp/client/qml/main.qml"></mcfile>、<mcfile name="LoginWindow.qml" path="d:/QT_Learn/Projects/QKChatApp/client/qml/LoginWindow.qml"></mcfile> 和 <mcfile name="RegisterWindow.qml" path="d:/QT_Learn/Projects/QKChatApp/client/qml/RegisterWindow.qml"></mcfile> 中又分别创建了各自的 ConfigManager 实例
- 这导致主题切换按钮修改的是局部实例的属性，而 Material 主题绑定的是全局实例的属性

## 解决方案

### 1. 统一使用全局 ConfigManager 实例
- **删除了** main.qml、LoginWindow.qml、RegisterWindow.qml 中的本地 ConfigManager 实例
- **统一使用** main.cpp 中暴露的全局 `configManager` 对象

### 2. 优化配置加载时机
- **在 main.cpp 中提前加载配置**：确保 QML 加载时配置已经就绪
- **删除了** main.qml 中重复的 `configManager.loadConfig()` 调用

### 3. 改进信号监听
- **在 main.qml 中添加 Connections**：监听全局 configManager 的 `isDarkThemeChanged` 信号
- **添加控制台日志**：方便调试主题切换状态

## 修改文件清单

1. **<mcfile name="main.cpp" path="d:/QT_Learn/Projects/QKChatApp/client/src/main.cpp"></mcfile>**：在 QML 加载前加载配置
2. **<mcfile name="main.qml" path="d:/QT_Learn/Projects/QKChatApp/client/qml/main.qml"></mcfile>**：删除本地 ConfigManager，使用 Connections 监听全局实例
3. **<mcfile name="LoginWindow.qml" path="d:/QT_Learn/Projects/QKChatApp/client/qml/LoginWindow.qml"></mcfile>**：删除本地 ConfigManager 实例
4. **<mcfile name="RegisterWindow.qml" path="d:/QT_Learn/Projects/QKChatApp/client/qml/RegisterWindow.qml"></mcfile>**：删除本地 ConfigManager 实例

## 技术要点

- **单例模式**：确保整个应用只有一个 ConfigManager 实例
- **属性绑定**：Material.theme 正确绑定到全局 configManager.isDarkTheme
- **信号机制**：通过 Qt 信号槽机制实现主题变化的实时响应
- **生命周期管理**：在 C++ 层面管理对象生命周期，QML 层面只使用引用

现在主题切换按钮应该可以正常工作了！点击按钮时会立即切换深色/浅色主题，并且设置会自动保存。