# 设计模式

## 客户端设计模式

### 1. MVVM（Model-View-ViewModel）模式
- **Model**：代表数据和业务逻辑（如消息列表、联系人列表）
- **View**：由QML实现的用户界面，负责展示数据
- **ViewModel**：作为Model和View之间的桥梁，将Model的数据暴露给View，并处理View的交互逻辑

### 2. 观察者模式
- 用于实现事件通知机制，例如当收到新消息时，通知各个界面更新
- 使用Qt的信号槽机制实现观察者模式

### 3. 单例模式
- 用于管理全局唯一的对象，如网络连接管理器、用户配置等
- 确保全局状态的一致性

### 4. 工厂模式
- 用于创建不同类型的消息对象（文本、图片、文件等）
- 简化对象创建逻辑，提高代码可维护性

## 服务器端设计模式

### 1. Reactor模式
- 使用Qt的`QSocketNotifier`或第三方库（如Boost.Asio）实现事件驱动
- 处理大量并发连接，提高I/O效率

### 2. 策略模式
- 用于不同的消息处理策略（如文本消息、文件消息、命令消息等）
- 便于扩展新的消息类型处理逻辑

### 3. 抽象工厂模式
- 用于创建不同的服务实例（如数据库服务、存储服务等）
- 便于切换实现，支持不同的部署环境

### 4. 单例模式
- 用于全局配置、日志服务等
- 确保全局资源的唯一性

### 5. 状态模式
- 用于管理用户会话状态（在线、离线、忙碌等）
- 简化状态转换逻辑

### 6. MVC模式（管理界面）
- **Model**：管理界面数据模型（用户数据、系统配置、监控数据等）
- **View**：Qt Widget界面组件，负责数据展示和用户交互
- **Controller**：处理用户操作，协调Model和View之间的交互

### 7. 命令模式（管理界面）
- 用于封装管理操作（如用户管理、系统配置等）
- 支持操作的撤销和重做
- 便于实现操作日志记录

### 8. 观察者模式（管理界面）
- 用于实时数据更新，如监控数据变化时自动刷新界面
- 使用Qt的信号槽机制实现数据绑定

## 线程池设计

### 客户端线程池
客户端采用Qt的`QThreadPool`和`QRunnable`来管理并发任务：

- **主线程**：负责UI渲染和事件处理
- **网络线程**：使用线程池处理网络请求（发送消息、文件传输等），避免阻塞UI
- **数据库线程**：使用单独的线程进行本地SQLite数据库操作

### 服务器端线程池
服务器端采用固定大小的线程池（避免资源耗尽），每个线程运行一个事件循环（Event Loop）：

- **主线程**：负责监听端口，接受新连接，并将新连接分发给工作线程
- **I/O线程**：每个线程处理多个连接的I/O事件（使用非阻塞I/O和事件通知机制）
- **工作线程**：处理业务逻辑（如消息转发、数据库操作等），避免阻塞I/O线程
- **管理界面线程**：独立线程处理管理界面的UI事件和业务逻辑（新增）

## 线程间通信

### 客户端线程通信
- 使用信号槽机制（Qt的自动连接方式，跨线程队列连接）
- 网络线程与主线程之间通过信号槽进行数据传递
- 数据库操作通过异步任务队列处理

### 服务器端线程通信
- I/O线程与工作线程之间使用任务队列（生产者-消费者模型）
- 使用Qt的信号槽进行跨线程通知（注意：使用`Qt::QueuedConnection`）
- 管理界面线程通过信号槽与核心服务通信（新增）

## 服务器端线程模型优化

1. **I/O线程**：仅负责网络数据的接收和发送，不处理业务逻辑
2. **工作线程**：从任务队列中取出任务并执行，如消息处理、数据库操作等
3. **数据库连接池**：每个工作线程使用独立的数据库连接，避免竞争
4. **管理界面线程**：独立线程处理UI事件，避免阻塞核心服务（新增）

## 管理界面设计模式应用

### 数据绑定模式
```cpp
// 使用Qt的属性系统实现数据绑定
class UserModel : public QObject
{
    Q_OBJECT
    Q_PROPERTY(QString username READ username WRITE setUsername NOTIFY usernameChanged)
    Q_PROPERTY(QString status READ status WRITE setStatus NOTIFY statusChanged)
    
public:
    QString username() const { return _username; }
    void setUsername(const QString &username);
    
signals:
    void usernameChanged();
    void statusChanged();
};
```

### 命令模式实现
```cpp
// 管理操作命令基类
class AdminCommand : public QObject
{
    Q_OBJECT
public:
    virtual void execute() = 0;
    virtual void undo() = 0;
    virtual QString description() const = 0;
};

// 用户管理命令
class UserManagementCommand : public AdminCommand
{
public:
    void execute() override;
    void undo() override;
    QString description() const override;
};
```

## 总结

- **客户端**：使用MVVM模式分离界面与逻辑，线程池处理耗时操作，保证UI流畅
- **服务器端**：Reactor模式处理高并发连接，线程池分离I/O和业务逻辑，任务队列实现负载均衡
- **管理界面**：使用MVC模式组织代码，命令模式处理用户操作，观察者模式实现实时数据更新 